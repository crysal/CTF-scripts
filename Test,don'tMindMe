#!/bin/bash
#1 blank pixel = l
#Multiple l's = / (sed 's/l.*l/\//g')
#>1 non blank = -
# 1 non blank = . 
#convert $input1 -crop 1x1+1+1 txt:-
#1x1 = only show 1 pixel
#+1+1= move one down & move one left
#convert $input1 -crop 1x1+$CurrentYCord+$CurrentXCord txt:-

#Checks if deps are installed
if [ $(command -v convert) ]; then echo "Installed"; else echo "Install imagemagick (using the convert)"; exit 0; fi


input1=$1
BackgroundValue=$(awk "BEGIN {print $(convert $input1 -crop 1x1+0+0 txt:- | tail -1 | awk '{print $4}' | sed 's/srgb(//g' | sed 's/)//g' | sed 's/,/+/g')}")
#getting combined rgb values of background (should be uniqe for each sample)
DotValue=$(awk "BEGIN {print $(convert $input1 -crop 1x1+1+1 txt:- | tail -1 | awk '{print $4}' | sed 's/srgb(//g' | sed 's/)//g' | sed 's/,/+/g')}")
#getting combined rgb values of dots (should be uniqe for each sample)

SizeX=$(file $input1 | awk '{print $5}')
SizeY=$(file $input1 | awk '{print $7}' | sed 's/,//g' )
#when setting cords based on file output remember to -1 cause of the offset of convert

CurrentXCord=1
CurrentYCord=1
while [ $CurrentYCord -lt $SizeY ] 
do

CurrentRGBValue=$(awk "BEGIN {print $(convert $input1 -crop 1x1+$CurrentXCord+$CurrentYCord txt:- | tail -1 | awk '{print $4}' | sed 's/srgb(//g' | sed 's/)//g' | sed 's/,/+/g')}")
BlankDecetcor=0 #Counter for blanks in a row, if goes above 1 should change row and put a slash(/)
DotDecetor=0    #Counter for dots and dashes, if goes to 1 then blank goes to 1 put a Dot (.), if goes above 2 then blank goes to 1 put a Dash (-)

	if [ $CurrentXCord -eq $SizeX ] #Checks if reached the edge of image, if goes to next line
		then
		CurrentXCord=0
		CurrentYCord=$(($CurrentYCord+1))
	fi
	
	if [ $CurrentRGBValue -eq $BackgroundValue ] #Checks if current pixel is a background
		then
		BlankDecetcor=$(($BlankDecetcor+1))
		CurrentXCord=$(($CurrentXCord+1))
		#Debug echo
		echo -ne "space" >> raw_morse 
		echo "Current value is the same as the background ($CurrentRGBValue = $BackgroundValue)"
	fi
	
	if [ $CurrentRGBValue -eq $DotValue ] #Checks if current pixel is a dot
		then
		DotDecetor=$(($DotDecetor+1))
		CurrentXCord=$(($CurrentXCord+1))
		#Debug echo
		echo "Current value is the same as a dot ($CurrentRGBValue = $DotValue)"
		echo -ne "dot" >> raw_morse
	fi
	
	if [ $BlankDecetcor -gt 1 ] #Checks if blanks have a number greater than 1, 
		then 
		echo "/" >> morse 
		BlankDecetcor=0
		DotDecetor=0
		CurrentYCord=$(($CurrentYCord+2))
		CurrentXCord=0
		#Debug echo
		echo "Dected more than one blank spot after eachother, check morse for a / and $CurrentYCord +2"
	fi
	
	if [ $DotDecetor -eq 1 ] && [ $BlankDecetcor -eq 1 ]
		then
		echo "." >> morse
		BlankDecetcor=0
		DotDecetor=0
		#Debug echo
		echo "Dected a blank space after one dot space, check morse for a . nothing more should happen for now"
	fi
	
	if [ $DotDecetor -gt 1 ] && [ $BlankDecetcor -eq 1 ]
		then
		echo "-" >> morse
		BlankDecetcor=0
		DotDecetor=0
		#Debug echo
		echo "Dected a blank after more than one dot space, check morse for a - nothing more should happen for now"
	fi
done

##ending checks of vars
echo "CurrentRGBValue = $CurrentRGBValue"
echo "CurrentXCord = $CurrentXCord"
echo "CurrentYCord = $CurrentYCord"
echo "BackgroundValue = $BackgroundValue"
echo "DotRGBValue = $DotValue"
echo "Size = $SizeX , $SizeY"


##TODO
#make loops
#make more loops in loops to make the loop loop around
#make it work
#text manipulate raw ourput to maybe work, would be easier
#make the double blank detection work, would eleminate double spaces
#
#
